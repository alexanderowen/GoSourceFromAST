// Program reads a (extremely) small subset of Go programs, parses it, and reconstructs
// it from the AST generated by the Go compiler
//
// Usage: 'go run main.go filename'

package main

import (
	pv "PrintVisitor"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
)

func main() {
	fn := os.Args[1]
	file, err := ioutil.ReadFile(fn)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading file\n")
		os.Exit(-1)
	}

	// Create the AST by parsing src.
	fset := token.NewFileSet() // token positions are relative to fset
	f, err := parser.ParseFile(fset, fn, file, 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing file: Not a .go file?\n")
		os.Exit(-1)
	}

	// Inspect (DFS-walk) the AST
	// Anon. func is called in encounter of each node
	pv.Inspect(f, func(n ast.Node) bool {
		//		var s string
		switch x := n.(type) {
		default:
			fmt.Printf("%T --> %+v\n", x, x)
			/*
				case *ast.File:
					s = "package"
					//		case *ast.GenDecl:
					//			s = fmt.Sprintf("\n%s ", x.Tok)
				case *ast.ValueSpec:
					s = fmt.Sprintf("%s = %s", x.Names[0], x.Values[0])
					//		case *ast.BasicLit:
					//			s = fmt.Sprintf(" %s ", x.Value)
					//		case *ast.Ident:
					//			s = fmt.Sprintf(" %s ", x.Name)
				}

				if s != "" {
					fmt.Printf("%s\n", s)
				}
			*/
			return true
		}
	})
}
